(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports);
        global.uuid = mod.exports;
    }
})(this, function (exports) {
    'use strict';
    var v1 = (function () {
        var seq = 0;
        var node;
        var clockseq;
        var lastTimestamp = 0;
        var UUID_TICKS_PER_MS = 10000;
        var UUID_EPOCH_OFFSET = 12219292800000;
        function generateNode() {
            var r = new Array(6);
            for (var i = 0; i < 6; i++) {
                r[i] = Math.floor(Math.random() * 256);
            }
            r[0] |= 0x01;
            return r;
        }
        function generateClockSeq() {
            return Math.floor(Math.random() * 0x4000);
        }
        return function (options, buf, offset) {
            var i = buf && offset || 0;
            if (typeof options == 'function') {
                buf = options;
                options = {};
            }
            if (!buf) {
                buf = new Array(16);
            }
            var timestamp = options && options.msecs !== undefined ? options.msecs : Date.now();
            timestamp = timestamp + UUID_EPOCH_OFFSET;
            var ticks = Math.floor(timestamp * UUID_TICKS_PER_MS);
            if (ticks < lastTimestamp) {
                clockseq = generateClockSeq();
            }
            if (!node) {
                node = options && options.node || generateNode();
            }
            if (clockseq === undefined) {
                clockseq = options && options.clockseq || generateClockSeq();
            }
            if (ticks <= lastTimestamp) {
                seq++;
                if (seq > 0x3fff) {
                    seq = 0;
                    clockseq = (clockseq + 1) & 0x3fff;
                }
            }
            lastTimestamp = ticks;
            var tl = ((ticks % 0x100000000) & 0xffffffff) | 0;
            var tmh = ((ticks / 0x100000000) & 0xffff) | 0;
            var tm = (tmh << 16) | (tl >>> 16);
            var th = ((tl & 0xffff) << 16) | (seq & 0x3fff);
            buf[i++] = (th >>> 24) & 0xff;
            buf[i++] = (th >>> 16) & 0xff;
            buf[i++] = (th >>> 8) & 0xff;
            buf[i++] = th & 0xff;
            buf[i++] = (tm >>> 8) & 0xff;
            buf[i++] = tm & 0xff;
            buf[i++] = ((clockseq >>> 8) & 0xff) | 0x80;
            buf[i++] = clockseq & 0xff;
            for (var n = 0; n < 6; n++) {
                buf[i++] = node[n];
            }
            return buf;
        };
    })();
    var v4 = (function () {
        return function (options, buf, offset) {
            var i = buf && offset || 0;
            if (typeof options == 'function') {
                buf = options;
                options = {};
            }
            if (!buf) {
                buf = new Array(16);
            }
            var rnds = options && options.random || options && options.rng || (function () {
                var r = new Array(16);
                for (var i = 0; i < 16; i++) {
                    r[i] = Math.floor(Math.random() * 256);
                }
                return r;
            })();
            rnds[6] = (rnds[6] & 0x0f) | 0x40;
            rnds[8] = (rnds[8] & 0x3f) | 0x80;
            for (var j = 0; j < 16; j++) {
                buf[i + j] = rnds[j];
            }
            return buf;
        };
    })();
    function bytesToUuid(buf, offset) {
        var i = offset || 0;
        var bth = [];
        for (var j = 0; j < 16; j++) {
            var b = buf[i + j];
            bth[j] = (b < 16 ? '0' : '') + b.toString(16);
        }
        return bth[0] + bth[1] + bth[2] + bth[3] + '-' +
            bth[4] + bth[5] + '-' +
            bth[6] + bth[7] + '-' +
            bth[8] + bth[9] + '-' +
            bth[10] + bth[11] + bth[12] + bth[13] + bth[14] + bth[15];
    }
    function uuidToBytes(uuid) {
        var bytes = [];
        uuid.replace(/[a-fA-F0-9]/g, function (c, i) {
            if (i % 3 === 0 && i !== 0 && i !== 17 && i !== 22 && i !== 27) {
                return;
            }
            bytes.push(parseInt(c, 16));
        });
        return bytes;
    }
    function stringToBytes(str) {
        var bytes = [];
        for (var i = 0; i < str.length; i++) {
            bytes.push(str.charCodeAt(i) & 0xff);
        }
        return bytes;
    }
    var v35 = (function (name, version, hashfunc) {
        return function (namespace, buf, offset) {
            var i = buf && offset || 0;
            if (typeof namespace === 'string') {
                namespace = stringToBytes(namespace);
            }
            if (!Array.isArray(namespace) || namespace.length !== 16) {
                throw TypeError('namespace must be uuid string or an Array of 16 byte values');
            }
            var bytes = hashfunc(namespace.concat(stringToBytes(name)));
            bytes[6] = (bytes[6] & 0x0f) | version;
            bytes[8] = (bytes[8] & 0x3f) | 0x80;
            if (buf) {
                for (var j = 0; j < 16; j++) {
                    buf[i + j] = bytes[j];
                }
            }
            return buf || bytesToUuid(bytes);
        };
    });
    var v3 = v35('v3', 0x30, (function () {
        var crypto = typeof window !== 'undefined' && window.crypto || typeof global !== 'undefined' && global.crypto;
        return crypto && crypto.getRandomValues ? function (data) {
            var hash = new Uint8Array(16);
            crypto.getRandomValues(hash);
            for (var i = 0; i < 16; i++) {
                hash[i] = hash[i] ^ data[i];
            }
            return hash;
        } : function (data) {
            var hash = new Array(16);
            for (var i = 0; i < 16; i++) {
                hash[i] = Math.floor(Math.random() * 256) ^ data[i];
            }
            return hash;
        };
    })());
    var v5 = v35('v5', 0x50, (function () {
        var crypto = typeof window !== 'undefined' && window.crypto || typeof global !== 'undefined' && global.crypto;
        return crypto && crypto.getRandomValues ? function (data) {
            var hash = new Uint8Array(16);
            crypto.getRandomValues(hash);
            for (var i = 0; i < 16; i++) {
                hash[i] = hash[i] ^ data[i];
            }
            return hash;
        } : function (data) {
            var hash = new Array(16);
            for (var i = 0; i < 16; i++) {
                hash[i] = Math.floor(Math.random() * 256) ^ data[i];
            }
            return hash;
        };
    })());
    function validate(uuid) {
        return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(uuid);
    }
    function parse(uuid) {
        if (!validate(uuid)) {
            throw TypeError('Invalid UUID');
        }
        return uuidToBytes(uuid);
    }
    function stringify(buf, offset) {
        return bytesToUuid(buf, offset);
    }
    var NIL = '00000000-0000-0000-0000-000000000000';
    exports.NIL = NIL;
    exports.parse = parse;
    exports.stringify = stringify;
    exports.v1 = v1;
    exports.v3 = v3;
    exports.v4 = v4;
    exports.v5 = v5;
    exports.validate = validate;
    Object.defineProperty(exports, '__esModule', { value: true });
});
